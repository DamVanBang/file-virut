'use strict';

const _ = require('ooi/require')('each');
const path = require('path');
const fs = require('fs');
const Packagable = require('./packagable');
const Gittable = require('./gittable');
const Package = require('./package');
const rimraf = require('rimraf');

class Project extends Gittable {
  constructor(dir = process.cwd(), packsDir) {
    super(dir);
    if (!packsDir) {
      packsDir = this.pack.packages;
    }
    this.packsDir = path.resolve(dir, packsDir);
    this.packages = this.getPacks();
  }

  async fixChanges() {
    let packages = this.packages;
    for (let i = 0; i < packages.length; i++) {
      let pk = packages[i];
      await pk.send();
    }
  }

  async compile() {
    await this.clearPackages();
    await this.fixChanges();
    await this.updateDependencies();
    await this.send();
  }

  async clearPackages() {
    for (let i = 0; i < this.packages.length; i++) {
      let pk = this.packages[i],
        name = pk.name,
        p = path.resolve(this.dir, 'node_modules', name);
      this.removeDirectory(p);
    }
    return true;
  }

  removeDirectory(p) {
    return new Promise((resolve, reject) => {
      rimraf(p, () => resolve(true));
    });
  }

  async updateDependencies() {
    let newDeps = this.getDependencies(),
      deps = this.pack.dependencies,
      statDeps = {};
    _.each(Object.keys(newDeps), (name) => {
      let oldVersion = deps[name],
        newVersion = newDeps[name];
      if (oldVersion === newVersion) return;
      statDeps[name] =
        `${oldVersion}`.grey + ` => `.grey + `${newVersion}`.green;
    });
    _.each(newDeps, (version, name) => {
      if (!deps.hasOwnProperty(name)) return;
      deps[name] = version;
    });
    this.pack.dependencies = deps;
    this.writePackage();
    console.log('\nTotal:'.bold);
    console.log(
      Object.keys(statDeps)
        .map((name) => `  ${name}: ${statDeps[name]}`)
        .join('\n  ')
    );
  }

  getDependencies() {
    let dependencies = {};
    this.packages.forEach((pack) => {
      let name = pack.pack.name,
        version = pack.pack.version;
      dependencies[name] = `^${version}`;
    });
    return dependencies;
  }

  getPacks() {
    let packs = fs
      .readdirSync(this.packsDir)
      .filter(
        (name) => !name.startsWith('.') && !['node_modules'].includes(name)
      )
      .map((name) => path.resolve(this.packsDir, name))
      .filter((dir) => fs.statSync(dir).isDirectory())
      .map((dir) => new Package(dir));
    return packs;
  }
}

module.exports = Project;
