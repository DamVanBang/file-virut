'use strict';

const _ = require('ooi/require')('each', 'pick', 'flatten');
const Packagable = require('./packagable');
const git = require('isomorphic-git');
const fs = require('fs');
const path = require('path');
const Git = require('simple-git');
const util = require('./util');
require('colors');

const EXCLUDE = [
  '.git',
  'node_modules',
  'yarn.lock',
  '.nyc_output',
  'error.log',
  'debug.log',
];
const STATUSES_NEW = [
  '*modified',
  'modified',
  '*deleted',
  'deleted',
  '*added',
  'added',
  '*undeleted',
  '*undeletemodified',
];
const STATUSES_OLD = [
  'ignored',
  'unmodified',
  'absent',
  '*unmodified',
  '*absent',
];

const STATUSES = [...STATUSES_NEW, ...STATUSES_OLD];

class Gittable extends Packagable {
  constructor(...args) {
    super(...args);
    this.git = Git({
      baseDir: this.dir,
      binary: 'git',
      maxConcurrentProcesses: 6,
    });
  }

  // Git Commands ==============================================================

  status() {
    return new Promise((resolve, reject) => {
      this.git.status((err, stats) => {
        if (err) return reject(err);
        resolve(stats);
      });
    });
  }

  async send(publish = true) {
    let isChanged = await this.isChanged();
    console.log(
      `\nPackage`.grey,
      `${this.name}@${this.pack.version}`.white,
      `...`.grey
    );
    if (!isChanged) {
      console.log(`  No changes.`.grey);
      return false;
    }
    console.log(`  Changes found. Updating...`.grey);
    let message = `Version ${this.increment()}`;
    if (!fs.existsSync(path.resolve(__dirname, '.git'))) {
      await this.init();
    }
    await this.ensureRemote();
    await this.addAll();
    await this.commit(message);
    await this.push();
    this.pack.publish ? await this.publish() : '';
    console.log(
      `  Updated «${this.pack.name}@${this.pack.version}» package.`.green
    );
    return true;
  }

  async ensureRemote() {
    if (await this.hasRemote()) return;
    await this.addRemote();
  }

  hasRemote() {
    return new Promise((resolve, reject) => {
      this.git.getRemotes('origin', (err, remotes) =>
        resolve(!!remotes.length)
      );
    });
  }

  init() {
    return new Promise((resolve, reject) => {
      this.git.init(resolve);
    });
  }

  push() {
    return new Promise((resolve, reject) => {
      this.git.push(['-u', 'origin', 'master'], (err) => {
        if (err) {
          console.log('ERROR', err);
          return reject(err);
        }
        resolve();
      });
    });
  }

  async addRemote() {
    return new Promise((resolve, reject) => {
      this.git.addRemote('origin', this.pack.repository.url, resolve);
    });
  }

  async addAll() {
    return await util.exec('git add . --all', this.dir);
  }

  async isChanged() {
    return !!_.flatten.array(
      Object.values(
        _.pick(await this.status(), [
          'not_added',
          'conflicted',
          'created',
          'deleted',
          'modified',
          'renamed',
        ])
      )
    ).length;
  }

  commit(message) {
    return new Promise((resolve, reject) => {
      this.git.commit(message, () => {
        resolve();
      });
    });
  }

  add(files) {
    return new Promise((resolve, reject) => {
      this.git.add(files, () => {
        resolve(files);
      });
    });
  }

  async getFileStatus(file = 'README.md') {
    let status = await git.status({
      fs: fs,
      dir: this.dir,
      filepath: file,
    });
    return status;
  }

  async getAllFiles() {
    let files = new Set([
      ...(await this.getExistingFiles()),
      ...(await this.getFiles()),
    ]);
    return Array.from(files);
  }

  async getExistingFiles(d = '.') {
    let dir = path.resolve(this.dir, d),
      filenames = fs.readdirSync(dir),
      files = [];
    for (let i = 0; i < filenames.length; i++) {
      let p = path.resolve(dir, filenames[i]);
      if (fs.existsSync(p) && fs.statSync(p).isFile()) {
        files.push(p);
      }
      if (fs.existsSync(p) && fs.statSync(p).isDirectory()) {
        let untracked = await this.getExistingFiles(p);
        files = [...files, ...untracked];
      }
    }
    return files
      .filter((file) => {
        for (let i = 0; i < EXCLUDE.length; i++) {
          let exclude = EXCLUDE[i];
          if (file.toLowerCase().includes(exclude)) return false;
        }
        return true;
      })
      .map((filename) => path.relative(this.dir, filename));
  }

  async getStat() {
    let files = await this.getFilesByStatus(),
      changed = await this.getChangedFiles(files),
      unchanged = await this.getUnchangedFiles(files);
    return [changed.length, unchanged.length];
  }

  async getChangedFiles(fls) {
    let files = fls || (await this.getFilesByStatus()),
      changed = [];
    _.each(files, (names, status) => {
      if (STATUSES_OLD.includes(status)) return;
      changed = [...changed, ...names];
    });
    return changed;
  }

  async getUnchangedFiles(fls) {
    let files = fls || (await this.getFilesByStatus()),
      unchanged = [];
    _.each(files, (names, status) => {
      if (STATUSES_NEW.includes(status)) return;
      unchanged = [...unchanged, ...names];
    });
    return unchanged;
  }

  async getFiles() {
    return await git.listFiles({ fs, dir: this.dir });
  }

  async getFilesByStatus() {
    let statuses = await this.getStatus(),
      names = Object.keys(statuses),
      results = {};
    STATUSES.forEach((status) => {
      results[status] = names.filter((name) => statuses[name] === status);
    });
    return results;
  }

  async getStatus() {
    let files = await this.getFiles(this.dir),
      statuses = {};
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      let status = await git.status({ fs, dir: this.dir, filepath: file });
      statuses[file] = status;
    }
    return statuses;
  }
}

module.exports = Gittable;
